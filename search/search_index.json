{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cheap Settings","text":"<p>A lightweight, low footprint settings system</p> <p> </p> <p><code>cheap-settings</code> is a Python package for providing a very simple, very low impact, configuration. The Python configuration &amp; settings landscape is virtually overflowing with clever, advanced, flexible solutions that cover many needs. However, what I needed was a bit different from any config/settings package that I was aware of.</p> <p>The main thing that distinguishes <code>cheap_settings</code> from any alternative solutions is simplicity: it is extremely simple (&amp; ergonomic) to use, &amp; it intentionally limits its scope &amp; feature set to be simple to understand.</p> <p>Additionally, it supports circumstances where it is difficult to bring your config file with you. All of your config is defined in the code or in the environment.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from cheap_settings import CheapSettings\n\nclass MySettings(CheapSettings):\n    host: str = \"localhost\"\n    port: int = 8080\n    debug: bool = False\n\n# Access settings\nprint(f\"Server: {MySettings.host}:{MySettings.port}\")\n\n# Override with environment variables\n# HOST=production.com PORT=443 DEBUG=true python myapp.py\n</code></pre> <p>Environment variables automatically override defaults with proper type conversion.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install cheap-settings\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Simple: Just inherit from <code>CheapSettings</code> and define typed attributes</li> <li>Environment variables: Automatic override with type conversion</li> <li>Command line: Optional CLI argument parsing</li> <li>Type safe: Full type hints and IDE support</li> <li>Inheritance: Settings classes can inherit from each other</li> <li>Pickleable: Works with Ray and other frameworks requiring serialization</li> <li>Zero dependencies: No external requirements</li> <li>Performance: Optional static snapshots for speed-critical code</li> </ul>"},{"location":"#why-cheap-settings","title":"Why Cheap Settings?","text":"<p>You want to configure something. You don't want to spend time configuring the configuration system. You just want it to work with minimal ceremony.</p> <p>That's exactly what <code>cheap-settings</code> provides.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#cheapsettings","title":"CheapSettings","text":""},{"location":"api/#cheap_settings.CheapSettings","title":"<code>cheap_settings.CheapSettings</code>","text":"<p>Base class for simple, environment-variable-driven configuration.</p> <p>Subclass this and define your settings as typed class attributes:</p> <pre><code>class MySettings(CheapSettings):\n    host: str = \"localhost\"\n    port: int = 8080\n    debug: bool = False\n</code></pre> Environment variables will override the defaults <p>HOST=example.com PORT=3000 DEBUG=true python myapp.py</p> <p>Supports all basic Python types plus datetime, date, time, Decimal, UUID, Path, Optional and Union types. Complex types (list, dict) are parsed from JSON strings.</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>class CheapSettings(metaclass=MetaCheapSettings):\n    \"\"\"Base class for simple, environment-variable-driven configuration.\n\n    Subclass this and define your settings as typed class attributes:\n\n        class MySettings(CheapSettings):\n            host: str = \"localhost\"\n            port: int = 8080\n            debug: bool = False\n\n    Environment variables will override the defaults:\n        HOST=example.com PORT=3000 DEBUG=true python myapp.py\n\n    Supports all basic Python types plus datetime, date, time, Decimal, UUID,\n    Path, Optional and Union types. Complex types (list, dict) are parsed from JSON strings.\n    \"\"\"\n\n    def __getattribute__(self, name):\n        \"\"\"Allow instances to access class-level settings.\"\"\"\n        # First try regular instance attribute access\n        try:\n            return object.__getattribute__(self, name)\n        except AttributeError:\n            # Fall back to class-level attribute access\n            # This allows instances to access settings defined at the class level\n            return getattr(type(self), name)\n\n    def __reduce__(self):\n        \"\"\"Enable pickling by returning class and state information.\"\"\"\n        # Try to return the class directly if it can be imported\n        try:\n            module = importlib.import_module(self.__class__.__module__)\n            if hasattr(module, self.__class__.__name__):\n                cls = getattr(module, self.__class__.__name__)\n                return cls, (), self.__getstate__()\n        except (ImportError, AttributeError):\n            pass\n\n        # Fallback to reconstruction\n        return (\n            _reconstruct_settings_instance,\n            (self.__class__.__module__, self.__class__.__name__),\n            self.__getstate__(),\n        )\n\n    def __getstate__(self):\n        \"\"\"Get the state for pickling - returns a dict of all settings.\"\"\"\n        # For CheapSettings, we don't actually have instance state\n        # All settings are class-level, so we just return an empty dict\n        return {}\n\n    def __setstate__(self, state):\n        \"\"\"Restore state when unpickling.\"\"\"\n        # Nothing to restore for CheapSettings instances\n        # All settings are accessed from the class level\n        pass\n\n    @classmethod\n    def to_static(cls) -&gt; object:\n        \"\"\"Create a static snapshot of current settings as a regular class.\n        The returned class is a regular Python class without any dynamic behavior.\n\n        Returns:\n             object: a new class with all settings resolved to their current values.\n\n        This is useful for:\n        - Performance-critical code where attribute access overhead matters\n        - Situations where you want to freeze settings at a point in time\n        - Working around edge cases with the dynamic metaclass behavior\n\n        Example:\n            &gt;&gt;&gt; class MySettings(CheapSettings):\n            ...     host: str = \"localhost\"\n            ...     port: int = 8080\n            &gt;&gt;&gt; StaticSettings = MySettings.to_static()\n            &gt;&gt;&gt; StaticSettings.host  # Just a regular class attribute\n            'localhost'\n        \"\"\"\n        # Collect all settings and their current resolved values\n        attrs = {}\n\n        # Get all settings from the class (including inherited ones)\n        for name in dir(cls):\n            # Skip private attributes and methods\n            if name.startswith(\"_\"):\n                continue\n\n            # Get the attribute value\n            try:\n                value = getattr(cls, name)\n            except AttributeError:\n                continue\n\n            # Skip methods and other callables\n            if callable(value):\n                continue\n\n            # Add the resolved value to our static class\n            attrs[name] = value\n\n        # Create a new regular class with the resolved values\n        static_class = type(f\"Static{cls.__name__}\", (), attrs)\n\n        # Copy the module for better repr and debugging\n        static_class.__module__ = cls.__module__\n\n        return static_class\n\n    @classmethod\n    def from_env(cls) -&gt; object:\n        \"\"\"Create a static snapshot with only values from environment variables.\n\n        Returns a regular Python class containing only the settings that are\n        explicitly set in environment variables, ignoring all defaults.\n\n        Returns:\n            object: A new class with only environment-sourced settings.\n\n        This is useful for:\n        - Debugging which settings are coming from the environment\n        - Creating minimal configuration objects\n        - Validating environment-only deployments\n\n        Example:\n            &gt;&gt;&gt; os.environ['HOST'] = 'example.com'\n            &gt;&gt;&gt; EnvOnly = MySettings.from_env()\n            &gt;&gt;&gt; EnvOnly.host  # 'example.com'\n            &gt;&gt;&gt; hasattr(EnvOnly, 'port')  # False (not in env)\n        \"\"\"\n        attrs = {}\n        config_instance = object.__getattribute__(cls, \"__config_instance\")\n        annotations = getattr(config_instance, \"__annotations__\", {})\n\n        # Only include attributes that have environment variables set\n        for name, type_hint in annotations.items():\n            env_name = name.upper()\n            if env_name in os.environ:\n                # Use the same logic as __getattribute__ to get the converted value\n                try:\n                    value = getattr(cls, name)\n                    attrs[name] = value\n                except (AttributeError, ValueError):\n                    # Skip if we can't get or convert the value\n                    pass\n\n        # Create a simple class with just the env values\n        env_class = type(f\"{cls.__name__}FromEnv\", (), attrs)\n        return env_class\n\n    @classmethod\n    def set_raise_on_uninitialized(cls, value: bool = True):\n        \"\"\"Set whether to raise an error when accessing uninitialized settings.\n\n        Args:\n            value: If True, accessing uninitialized settings raises AttributeError.\n                   If False, accessing uninitialized settings returns None (default).\n\n        Example:\n            &gt;&gt;&gt; class MySettings(CheapSettings):\n            ...     required_setting: str  # No default\n            &gt;&gt;&gt; MySettings.set_raise_on_uninitialized(True)\n            &gt;&gt;&gt; MySettings.required_setting  # Raises AttributeError\n        \"\"\"\n        config_instance = object.__getattribute__(cls, \"__config_instance\")\n        object.__setattr__(\n            config_instance, \"_MetaCheapSettings__raise_on_uninitialized_setting\", value\n        )\n\n    @classmethod\n    def set_config_from_command_line(cls, arg_parser=None, args=None):\n        \"\"\"Creates command line arguments (as flags) that correspond to the settings, &amp; parses them, setting the\n        config values based on them. Settings overridden by command line arguments take precedence over any\n        default variables, &amp; over environment variables. Currently, settings of `dict` &amp; `list` types are ignored,\n        &amp; no command line arguments are added for them. It can optionally take an instance of argparse.ArgumentParser\n        that can be used to pre-configure your own command line arguments. The optional `args` parameter allows\n        passing specific arguments for testing (if None, uses sys.argv). Returns the parsed arguments (an\n        instance of argparse.Namespace). Can raise various exceptions.\"\"\"\n\n        # Create a second config instance specifically for command line arguments. This adds a new class attribute\n        # called `__cli_config_instance`, &amp; adds any command line arguments that correspond to the attributes of\n        # `__config_instance`. It also copies any type annotations for the copied attributes.\n        try:\n            config_instance = object.__getattribute__(cls, \"__config_instance\")\n        except AttributeError:\n            raise AttributeError(\"Config instance has not been set.\")\n\n        if config_instance is None:\n            raise AttributeError(\"Config instance has not been set.\")\n\n        cli_config_instance = MetaCheapSettings.ConfigInstance()\n        parsed_args = parse_command_line_arguments(\n            config_instance, cli_config_instance, arg_parser, args\n        )\n        # Use type.__setattr__ to set attribute on the class\n        type.__setattr__(cls, \"__cli_config_instance\", cli_config_instance)\n\n        return parsed_args\n</code></pre>"},{"location":"api/#cheap_settings.CheapSettings.__getattribute__","title":"<code>__getattribute__(name)</code>","text":"<p>Allow instances to access class-level settings.</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>def __getattribute__(self, name):\n    \"\"\"Allow instances to access class-level settings.\"\"\"\n    # First try regular instance attribute access\n    try:\n        return object.__getattribute__(self, name)\n    except AttributeError:\n        # Fall back to class-level attribute access\n        # This allows instances to access settings defined at the class level\n        return getattr(type(self), name)\n</code></pre>"},{"location":"api/#cheap_settings.CheapSettings.__getstate__","title":"<code>__getstate__()</code>","text":"<p>Get the state for pickling - returns a dict of all settings.</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>def __getstate__(self):\n    \"\"\"Get the state for pickling - returns a dict of all settings.\"\"\"\n    # For CheapSettings, we don't actually have instance state\n    # All settings are class-level, so we just return an empty dict\n    return {}\n</code></pre>"},{"location":"api/#cheap_settings.CheapSettings.__reduce__","title":"<code>__reduce__()</code>","text":"<p>Enable pickling by returning class and state information.</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>def __reduce__(self):\n    \"\"\"Enable pickling by returning class and state information.\"\"\"\n    # Try to return the class directly if it can be imported\n    try:\n        module = importlib.import_module(self.__class__.__module__)\n        if hasattr(module, self.__class__.__name__):\n            cls = getattr(module, self.__class__.__name__)\n            return cls, (), self.__getstate__()\n    except (ImportError, AttributeError):\n        pass\n\n    # Fallback to reconstruction\n    return (\n        _reconstruct_settings_instance,\n        (self.__class__.__module__, self.__class__.__name__),\n        self.__getstate__(),\n    )\n</code></pre>"},{"location":"api/#cheap_settings.CheapSettings.__setstate__","title":"<code>__setstate__(state)</code>","text":"<p>Restore state when unpickling.</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>def __setstate__(self, state):\n    \"\"\"Restore state when unpickling.\"\"\"\n    # Nothing to restore for CheapSettings instances\n    # All settings are accessed from the class level\n    pass\n</code></pre>"},{"location":"api/#cheap_settings.CheapSettings.from_env","title":"<code>from_env()</code>  <code>classmethod</code>","text":"<p>Create a static snapshot with only values from environment variables.</p> <p>Returns a regular Python class containing only the settings that are explicitly set in environment variables, ignoring all defaults.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>A new class with only environment-sourced settings.</p> <p>This is useful for: - Debugging which settings are coming from the environment - Creating minimal configuration objects - Validating environment-only deployments</p> Example <p>os.environ['HOST'] = 'example.com' EnvOnly = MySettings.from_env() EnvOnly.host  # 'example.com' hasattr(EnvOnly, 'port')  # False (not in env)</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>@classmethod\ndef from_env(cls) -&gt; object:\n    \"\"\"Create a static snapshot with only values from environment variables.\n\n    Returns a regular Python class containing only the settings that are\n    explicitly set in environment variables, ignoring all defaults.\n\n    Returns:\n        object: A new class with only environment-sourced settings.\n\n    This is useful for:\n    - Debugging which settings are coming from the environment\n    - Creating minimal configuration objects\n    - Validating environment-only deployments\n\n    Example:\n        &gt;&gt;&gt; os.environ['HOST'] = 'example.com'\n        &gt;&gt;&gt; EnvOnly = MySettings.from_env()\n        &gt;&gt;&gt; EnvOnly.host  # 'example.com'\n        &gt;&gt;&gt; hasattr(EnvOnly, 'port')  # False (not in env)\n    \"\"\"\n    attrs = {}\n    config_instance = object.__getattribute__(cls, \"__config_instance\")\n    annotations = getattr(config_instance, \"__annotations__\", {})\n\n    # Only include attributes that have environment variables set\n    for name, type_hint in annotations.items():\n        env_name = name.upper()\n        if env_name in os.environ:\n            # Use the same logic as __getattribute__ to get the converted value\n            try:\n                value = getattr(cls, name)\n                attrs[name] = value\n            except (AttributeError, ValueError):\n                # Skip if we can't get or convert the value\n                pass\n\n    # Create a simple class with just the env values\n    env_class = type(f\"{cls.__name__}FromEnv\", (), attrs)\n    return env_class\n</code></pre>"},{"location":"api/#cheap_settings.CheapSettings.set_config_from_command_line","title":"<code>set_config_from_command_line(arg_parser=None, args=None)</code>  <code>classmethod</code>","text":"<p>Creates command line arguments (as flags) that correspond to the settings, &amp; parses them, setting the config values based on them. Settings overridden by command line arguments take precedence over any default variables, &amp; over environment variables. Currently, settings of <code>dict</code> &amp; <code>list</code> types are ignored, &amp; no command line arguments are added for them. It can optionally take an instance of argparse.ArgumentParser that can be used to pre-configure your own command line arguments. The optional <code>args</code> parameter allows passing specific arguments for testing (if None, uses sys.argv). Returns the parsed arguments (an instance of argparse.Namespace). Can raise various exceptions.</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>@classmethod\ndef set_config_from_command_line(cls, arg_parser=None, args=None):\n    \"\"\"Creates command line arguments (as flags) that correspond to the settings, &amp; parses them, setting the\n    config values based on them. Settings overridden by command line arguments take precedence over any\n    default variables, &amp; over environment variables. Currently, settings of `dict` &amp; `list` types are ignored,\n    &amp; no command line arguments are added for them. It can optionally take an instance of argparse.ArgumentParser\n    that can be used to pre-configure your own command line arguments. The optional `args` parameter allows\n    passing specific arguments for testing (if None, uses sys.argv). Returns the parsed arguments (an\n    instance of argparse.Namespace). Can raise various exceptions.\"\"\"\n\n    # Create a second config instance specifically for command line arguments. This adds a new class attribute\n    # called `__cli_config_instance`, &amp; adds any command line arguments that correspond to the attributes of\n    # `__config_instance`. It also copies any type annotations for the copied attributes.\n    try:\n        config_instance = object.__getattribute__(cls, \"__config_instance\")\n    except AttributeError:\n        raise AttributeError(\"Config instance has not been set.\")\n\n    if config_instance is None:\n        raise AttributeError(\"Config instance has not been set.\")\n\n    cli_config_instance = MetaCheapSettings.ConfigInstance()\n    parsed_args = parse_command_line_arguments(\n        config_instance, cli_config_instance, arg_parser, args\n    )\n    # Use type.__setattr__ to set attribute on the class\n    type.__setattr__(cls, \"__cli_config_instance\", cli_config_instance)\n\n    return parsed_args\n</code></pre>"},{"location":"api/#cheap_settings.CheapSettings.set_raise_on_uninitialized","title":"<code>set_raise_on_uninitialized(value=True)</code>  <code>classmethod</code>","text":"<p>Set whether to raise an error when accessing uninitialized settings.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>bool</code> <p>If True, accessing uninitialized settings raises AttributeError.    If False, accessing uninitialized settings returns None (default).</p> <code>True</code> Example <p>class MySettings(CheapSettings): ...     required_setting: str  # No default MySettings.set_raise_on_uninitialized(True) MySettings.required_setting  # Raises AttributeError</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>@classmethod\ndef set_raise_on_uninitialized(cls, value: bool = True):\n    \"\"\"Set whether to raise an error when accessing uninitialized settings.\n\n    Args:\n        value: If True, accessing uninitialized settings raises AttributeError.\n               If False, accessing uninitialized settings returns None (default).\n\n    Example:\n        &gt;&gt;&gt; class MySettings(CheapSettings):\n        ...     required_setting: str  # No default\n        &gt;&gt;&gt; MySettings.set_raise_on_uninitialized(True)\n        &gt;&gt;&gt; MySettings.required_setting  # Raises AttributeError\n    \"\"\"\n    config_instance = object.__getattribute__(cls, \"__config_instance\")\n    object.__setattr__(\n        config_instance, \"_MetaCheapSettings__raise_on_uninitialized_setting\", value\n    )\n</code></pre>"},{"location":"api/#cheap_settings.CheapSettings.to_static","title":"<code>to_static()</code>  <code>classmethod</code>","text":"<p>Create a static snapshot of current settings as a regular class. The returned class is a regular Python class without any dynamic behavior.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>Type[Any]</code> <p>a new class with all settings resolved to their current values.</p> <p>This is useful for: - Performance-critical code where attribute access overhead matters - Situations where you want to freeze settings at a point in time - Working around edge cases with the dynamic metaclass behavior</p> Example <p>class MySettings(CheapSettings): ...     host: str = \"localhost\" ...     port: int = 8080 StaticSettings = MySettings.to_static() StaticSettings.host  # Just a regular class attribute 'localhost'</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>@classmethod\ndef to_static(cls) -&gt; object:\n    \"\"\"Create a static snapshot of current settings as a regular class.\n    The returned class is a regular Python class without any dynamic behavior.\n\n    Returns:\n         object: a new class with all settings resolved to their current values.\n\n    This is useful for:\n    - Performance-critical code where attribute access overhead matters\n    - Situations where you want to freeze settings at a point in time\n    - Working around edge cases with the dynamic metaclass behavior\n\n    Example:\n        &gt;&gt;&gt; class MySettings(CheapSettings):\n        ...     host: str = \"localhost\"\n        ...     port: int = 8080\n        &gt;&gt;&gt; StaticSettings = MySettings.to_static()\n        &gt;&gt;&gt; StaticSettings.host  # Just a regular class attribute\n        'localhost'\n    \"\"\"\n    # Collect all settings and their current resolved values\n    attrs = {}\n\n    # Get all settings from the class (including inherited ones)\n    for name in dir(cls):\n        # Skip private attributes and methods\n        if name.startswith(\"_\"):\n            continue\n\n        # Get the attribute value\n        try:\n            value = getattr(cls, name)\n        except AttributeError:\n            continue\n\n        # Skip methods and other callables\n        if callable(value):\n            continue\n\n        # Add the resolved value to our static class\n        attrs[name] = value\n\n    # Create a new regular class with the resolved values\n    static_class = type(f\"Static{cls.__name__}\", (), attrs)\n\n    # Copy the module for better repr and debugging\n    static_class.__module__ = cls.__module__\n\n    return static_class\n</code></pre>"},{"location":"api/#reserved-names","title":"Reserved Names","text":"<p>The attribute name <code>__cheap_settings__</code> is reserved for future configuration of cheap-settings behavior. Do not use this name for your settings.</p> <pre><code># \u274c Don't do this\nclass MySettings(CheapSettings):\n    __cheap_settings__: dict = {}  # Reserved!\n\n# \u2705 Do this instead\nclass MySettings(CheapSettings):\n    my_settings: dict = {}\n</code></pre>"},{"location":"api/#type-support","title":"Type Support","text":"<p><code>cheap-settings</code> automatically converts environment variable strings to the appropriate Python types based on type annotations.</p>"},{"location":"api/#supported-types","title":"Supported Types","text":"Type Example Environment Variable Notes <code>str</code> <code>\"hello\"</code> <code>VALUE=\"hello\"</code> No conversion needed <code>int</code> <code>42</code> <code>VALUE=\"42\"</code> Converted with <code>int()</code> <code>float</code> <code>3.14</code> <code>VALUE=\"3.14\"</code> Converted with <code>float()</code> <code>bool</code> <code>True</code> <code>VALUE=\"true\"</code> Accepts: true/false, yes/no, on/off, 1/0 (case-insensitive) <code>pathlib.Path</code> <code>Path(\"/etc\")</code> <code>VALUE=\"/etc\"</code> Converted with <code>Path()</code> <code>datetime</code> <code>datetime(2024, 12, 25, 15, 30)</code> <code>VALUE=\"2024-12-25T15:30:00\"</code> ISO format (fromisoformat) <code>date</code> <code>date(2024, 12, 25)</code> <code>VALUE=\"2024-12-25\"</code> ISO format (YYYY-MM-DD) <code>time</code> <code>time(15, 30, 45)</code> <code>VALUE=\"15:30:45\"</code> ISO format (HH:MM:SS) <code>Decimal</code> <code>Decimal(\"99.99\")</code> <code>VALUE=\"99.99\"</code> Preserves precision <code>UUID</code> <code>UUID(\"...\")</code> <code>VALUE=\"550e8400-...\"</code> With/without hyphens <code>list</code> <code>[1, 2, 3]</code> <code>VALUE='[1, 2, 3]'</code> Parsed as JSON <code>dict</code> <code>{\"key\": \"value\"}</code> <code>VALUE='{\"key\": \"value\"}'</code> Parsed as JSON Custom types Any type with <code>from_string()</code> <code>VALUE=\"custom format\"</code> Calls <code>Type.from_string(value)</code> <code>Optional[T]</code> <code>None</code> or <code>T</code> <code>VALUE=\"none\"</code> or valid <code>T</code> Special \"none\" string sets to None <code>Union[T, U]</code> <code>T</code> or <code>U</code> Valid for either type Tries each type in order"},{"location":"api/#extended-type-examples","title":"Extended Type Examples","text":""},{"location":"api/#date-and-time-types","title":"Date and Time Types","text":"<pre><code>from datetime import datetime, date, time\nfrom cheap_settings import CheapSettings\n\nclass TimeSettings(CheapSettings):\n    created_at: datetime = datetime(2024, 1, 1)\n    expiry_date: date = date(2024, 12, 31)\n    backup_time: time = time(3, 0, 0)\n\n# Environment variables:\n# CREATED_AT=\"2024-12-25T15:30:45.123456\"  # With microseconds\n# CREATED_AT=\"2024-12-25T15:30:45+05:30\"   # With timezone\n# EXPIRY_DATE=\"2025-01-01\"\n# BACKUP_TIME=\"02:30:00\"\n</code></pre>"},{"location":"api/#decimal-for-financial-precision","title":"Decimal for Financial Precision","text":"<pre><code>from decimal import Decimal\n\nclass PricingSettings(CheapSettings):\n    product_price: Decimal = Decimal(\"99.99\")\n    tax_rate: Decimal = Decimal(\"0.0825\")  # 8.25%\n\n# Preserves exact decimal precision\n# PRODUCT_PRICE=\"149.99\"\n# TAX_RATE=\"0.0925\"\n\n# Calculate with precision\ntax = PricingSettings.product_price * PricingSettings.tax_rate\n</code></pre>"},{"location":"api/#uuid-for-unique-identifiers","title":"UUID for Unique Identifiers","text":"<pre><code>from uuid import UUID\n\nclass ServiceSettings(CheapSettings):\n    instance_id: UUID = UUID(\"00000000-0000-0000-0000-000000000000\")\n\n# Accepts multiple formats:\n# INSTANCE_ID=\"550e8400-e29b-41d4-a716-446655440000\"  # Standard\n# INSTANCE_ID=\"550e8400e29b41d4a716446655440000\"      # No hyphens\n# INSTANCE_ID=\"{550e8400-e29b-41d4-a716-446655440000}\" # With braces\n</code></pre>"},{"location":"api/#custom-types-with-from_string","title":"Custom Types with <code>from_string()</code>","text":"<p>Any custom type that implements a <code>from_string()</code> class method will work automatically:</p> <pre><code>class Temperature:\n    def __init__(self, celsius: float):\n        self.celsius = celsius\n\n    @classmethod\n    def from_string(cls, value: str) -&gt; 'Temperature':\n        if value.endswith('F'):\n            # Convert Fahrenheit to Celsius\n            fahrenheit = float(value[:-1])\n            celsius = (fahrenheit - 32) * 5/9\n            return cls(celsius)\n        else:\n            # Assume Celsius\n            return cls(float(value))\n\nclass Settings(CheapSettings):\n    room_temp: Temperature = Temperature(20.0)\n\n# Environment variables work automatically:\n# ROOM_TEMP=\"72F\"  # Converts to Temperature(22.2)\n# ROOM_TEMP=\"25\"   # Converts to Temperature(25.0)\n</code></pre>"},{"location":"api/#environment-variable-naming","title":"Environment Variable Naming","text":"<p>Environment variables are the uppercase version of the attribute name:</p> <pre><code>class Settings(CheapSettings):\n    database_url: str = \"localhost\"     # DATABASE_URL\n    api_timeout: int = 30               # API_TIMEOUT\n    enable_cache: bool = False          # ENABLE_CACHE\n</code></pre>"},{"location":"api/#command-line-arguments","title":"Command Line Arguments","text":"<p>Command line arguments are the lowercase, hyphenated version of the attribute name:</p> <pre><code>class Settings(CheapSettings):\n    database_url: str = \"localhost\"     # --database-url\n    api_timeout: int = 30               # --api-timeout\n    enable_cache: bool = False          # --enable-cache / --no-enable-cache\n</code></pre>"},{"location":"api/#boolean-command-line-behavior","title":"Boolean Command Line Behavior","text":"<p>Boolean handling differs based on whether the type is Optional:</p> <ul> <li> <p>Non-Optional booleans (<code>bool = False/True</code>) create both positive and negative flags:   <code>python   class Settings(CheapSettings):       debug: bool = False    # Creates both --debug and --no-debug       secure: bool = True    # Creates both --secure and --no-secure</code>   This allows you to override environment variables in either direction:   <code>bash   # Environment: DEBUG=true, SECURE=false   python app.py --no-debug --secure  # Override both values</code></p> </li> <li> <p>Optional booleans (<code>Optional[bool]</code>) accept explicit values:   <code>python   class Settings(CheapSettings):       debug: Optional[bool] = None    # --debug true/false/1/0/yes/no</code></p> </li> </ul> <p>Both approaches allow overriding environment variables, but non-Optional booleans provide a cleaner flag-based interface.</p>"},{"location":"api/#inheritance","title":"Inheritance","text":"<p>Settings classes support inheritance. Child classes inherit all settings from parent classes and can override them:</p> <pre><code>class BaseSettings(CheapSettings):\n    timeout: int = 30\n\nclass WebSettings(BaseSettings):\n    timeout: int = 60  # Override parent\n    port: int = 8080   # Add new setting\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<ul> <li>Type conversion errors: If an environment variable can't be converted to the expected type, a <code>ValueError</code> is raised with details</li> <li>JSON parsing errors: For <code>list</code> and <code>dict</code> types, JSON parsing errors include helpful messages</li> <li>Missing attributes: Accessing undefined settings raises <code>AttributeError</code></li> </ul>"},{"location":"api/#performance","title":"Performance","text":"<p>For performance-critical code where attribute access overhead matters, use <code>to_static()</code> to create a snapshot with no dynamic behavior:</p> <pre><code>Settings = MyDynamicSettings.to_static()\n# Now Settings.value is just a regular class attribute\n</code></pre>"},{"location":"api/#environment-only-settings","title":"Environment-Only Settings","text":"<p>The <code>from_env()</code> method returns a class containing only settings that are explicitly set in environment variables:</p> <pre><code>EnvOnly = MySettings.from_env()\n# EnvOnly only has attributes for settings with environment variables\n</code></pre> <p>This is useful for debugging deployments or validating environment configuration.</p>"},{"location":"api/#settings-without-initializers","title":"Settings Without Initializers","text":"<p>You can define settings with type annotations but no default values:</p> <pre><code>class MySettings(CheapSettings):\n    required_api_key: str  # No default value\n    optional_timeout: Optional[int]  # No default, Optional type\n</code></pre> <p>By default, accessing uninitialized settings returns <code>None</code>:</p> <pre><code>assert MySettings.required_api_key is None\nassert MySettings.optional_timeout is None\n</code></pre> <p>Environment variables work normally with uninitialized settings:</p> <pre><code>os.environ[\"REQUIRED_API_KEY\"] = \"secret123\"\nassert MySettings.required_api_key == \"secret123\"\n</code></pre> <p>For stricter validation, use <code>set_raise_on_uninitialized(True)</code> to make accessing uninitialized settings raise <code>AttributeError</code>:</p> <pre><code>MySettings.set_raise_on_uninitialized(True)\nMySettings.required_api_key  # Raises AttributeError if not in environment\n</code></pre> <p>Note: settings with <code>Optional</code> types (or unions with <code>None</code>), never raise when uninitialized. They always return <code>None</code> even if you <code>set_raise_on_uninitialized(True)</code>.</p>"},{"location":"api/#working-with-credentials-and-env-files","title":"Working with Credentials and .env Files","text":"<p>For sensitive settings like API keys or passwords, use <code>Optional</code> types with no default:</p> <pre><code>class Settings(CheapSettings):\n    api_key: Optional[str] = None\n    db_password: Optional[str] = None\n</code></pre> <p>Since <code>cheap-settings</code> reads environment variables dynamically, it works seamlessly with <code>python-dotenv</code>:</p> <pre><code>from dotenv import load_dotenv\nfrom cheap_settings import CheapSettings\n\nload_dotenv()  # Load .env file into environment\n# Settings will automatically pick up the values\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>The best way to understand <code>cheap-settings</code> is through examples. All examples are runnable - you can copy and paste them into Python files.</p>"},{"location":"examples/#basic-usage","title":"Basic Usage","text":"<p>The simplest way to use cheap-settings:</p> <pre><code>from cheap_settings import CheapSettings\n\nclass AppSettings(CheapSettings):\n    \"\"\"Application configuration.\"\"\"\n    host: str = \"localhost\"\n    port: int = 8080\n    debug: bool = False\n    app_name: str = \"MyApp\"\n\n# Access settings directly as class attributes\nprint(f\"Host: {AppSettings.host}\")\nprint(f\"Port: {AppSettings.port}\")\nprint(f\"Server: http://{AppSettings.host}:{AppSettings.port}\")\n</code></pre>"},{"location":"examples/#environment-variables","title":"Environment Variables","text":"<p>Environment variables automatically override defaults with type conversion:</p> <pre><code>import os\nfrom cheap_settings import CheapSettings\n\nclass Settings(CheapSettings):\n    database_host: str = \"localhost\"\n    database_port: int = 5432\n    connection_timeout: float = 30.0\n    use_ssl: bool = False\n\n# Set environment variables\nos.environ[\"DATABASE_HOST\"] = \"prod.example.com\"\nos.environ[\"DATABASE_PORT\"] = \"3306\"  # Converted to int\nos.environ[\"USE_SSL\"] = \"true\"        # Converted to bool\n\nprint(f\"Database: {Settings.database_host}:{Settings.database_port}\")\nprint(f\"SSL: {Settings.use_ssl} ({type(Settings.use_ssl).__name__})\")\n</code></pre>"},{"location":"examples/#command-line-arguments","title":"Command Line Arguments","text":"<p>Automatically create CLI arguments from your settings:</p> <pre><code>from cheap_settings import CheapSettings\n\nclass ServerConfig(CheapSettings):\n    host: str = \"0.0.0.0\"\n    port: int = 8000\n    workers: int = 4\n    reload: bool = False\n\n# Parse command line arguments\nServerConfig.set_config_from_command_line()\n\nprint(f\"Server: {ServerConfig.host}:{ServerConfig.port}\")\nprint(f\"Workers: {ServerConfig.workers}\")\n</code></pre> <p>Run with: <code>python server.py --host localhost --port 3000 --workers 8 --reload</code></p>"},{"location":"examples/#inheritance","title":"Inheritance","text":"<p>Settings classes can inherit from each other:</p> <pre><code>from cheap_settings import CheapSettings\n\nclass BaseConfig(CheapSettings):\n    app_name: str = \"MyApplication\"\n    version: str = \"1.0.0\"\n    timeout: int = 30\n\nclass DatabaseConfig(BaseConfig):\n    db_host: str = \"localhost\"\n    db_port: int = 5432\n    db_name: str = \"myapp\"\n\nclass ProductionConfig(DatabaseConfig):\n    debug: bool = False\n    db_host: str = \"prod.db.example.com\"  # Override parent\n    ssl_required: bool = True\n\nprint(f\"App: {ProductionConfig.app_name} v{ProductionConfig.version}\")\nprint(f\"Database: {ProductionConfig.db_host}:{ProductionConfig.db_port}\")\n</code></pre>"},{"location":"examples/#type-conversion","title":"Type Conversion","text":"<p>All basic Python types are supported, with or without type annotations:</p> <pre><code>from pathlib import Path\nfrom typing import Optional\nfrom cheap_settings import CheapSettings\n\nclass TypedSettings(CheapSettings):\n    # Explicit type annotations\n    text: str = \"default\"\n    number: int = 42\n    ratio: float = 3.14\n    enabled: bool = False\n\n    # Type inference from defaults (no annotations needed!)\n    host = \"localhost\"  # Infers str\n    port = 8080  # Infers int\n    timeout = 30.5  # Infers float\n    debug = False  # Infers bool\n\n    # Path support\n    config_dir: Path = Path(\"/etc/myapp\")\n    # Or inferred:\n    log_dir = Path(\"/var/log\")  # Infers Path\n\n    # JSON types\n    tags: list = [\"python\", \"config\"]\n    metadata: dict = {\"version\": 1}\n\n    # Optional types (need explicit annotation)\n    api_key: Optional[str] = None\n\n# Environment variables are converted automatically:\n# TEXT=\"hello\" NUMBER=\"99\" ENABLED=\"true\" CONFIG_DIR=\"/custom/path\"\n# TAGS='[\"web\", \"api\"]' METADATA='{\"env\": \"prod\"}' API_KEY=\"secret\"\n</code></pre>"},{"location":"examples/#static-snapshots","title":"Static Snapshots","text":"<p>For performance-critical code, create static snapshots:</p> <pre><code>from cheap_settings import CheapSettings\n\nclass DynamicSettings(CheapSettings):\n    api_url: str = \"https://api.example.com\"\n    timeout: int = 30\n    retry_count: int = 3\n\n# Create a static snapshot (frozen values)\nStaticSettings = DynamicSettings.to_static()\n\n# Static class has no dynamic behavior - just fast attribute access\nprint(f\"API: {StaticSettings.api_url}\")\nprint(f\"Type: {type(StaticSettings)}\")  # Regular Python class\n</code></pre>"},{"location":"examples/#pickle-support","title":"Pickle Support","text":"<p>Works with Ray and other frameworks requiring serialization:</p> <pre><code>import pickle\nfrom cheap_settings import CheapSettings\n\nclass Config(CheapSettings):\n    host: str = \"localhost\"\n    port: int = 8080\n\n# Pickle and unpickle\npickled = pickle.dumps(Config)\nunpickled_class = pickle.loads(pickled)\n\nassert unpickled_class.host == Config.host\nprint(\"\u2713 Pickle support works!\")\n</code></pre>"},{"location":"examples/#more-examples","title":"More Examples","text":"<p>For complete runnable examples, see the examples directory in the repository.</p>"},{"location":"python-3.14-issues/","title":"Python 3.14 Compatibility Issues","text":""},{"location":"python-3.14-issues/#status-not-currently-supported","title":"Status: Not Currently Supported","text":"<p>As of November 2025, cheap-settings does not support Python 3.14 due to fundamental changes in how Python handles annotations.</p>"},{"location":"python-3.14-issues/#the-root-cause-pep-649","title":"The Root Cause: PEP 649","text":"<p>Python 3.14 implements PEP 649 - Deferred Evaluation of Annotations, which fundamentally changes how annotations work:</p> <ul> <li>Before 3.14: Annotations were evaluated at class definition time and stored in <code>__annotations__</code></li> <li>After 3.14: Annotations are lazily evaluated via <code>__annotate_func__()</code> when accessed</li> </ul>"},{"location":"python-3.14-issues/#specific-failures","title":"Specific Failures","text":""},{"location":"python-3.14-issues/#1-optionalunion-types-not-converting","title":"1. Optional/Union Types Not Converting","text":"<pre><code># Expected: Settings.timeout == 30 (int)\n# Actual: Settings.timeout == '30' (str)\n</code></pre> <ul> <li>Optional types return raw strings instead of converted values</li> <li>Affects: <code>Optional[int]</code>, <code>Optional[str]</code>, <code>Optional[datetime]</code>, etc.</li> <li>Test failures: All <code>test_optional_*</code> tests</li> </ul>"},{"location":"python-3.14-issues/#2-uninitialized-settings-not-recognized","title":"2. Uninitialized Settings Not Recognized","text":"<pre><code>class Settings(CheapSettings):\n    api_key: str  # No default value\n\n# Expected: Settings.api_key returns None or raises\n# Actual: AttributeError: no attribute 'api_key'\n</code></pre> <ul> <li>Attributes with only type annotations (no defaults) aren't being detected</li> <li>The metaclass can't find these attributes during class creation</li> <li>Test failures: All <code>test_uninitialized_*</code> tests</li> </ul>"},{"location":"python-3.14-issues/#3-new-__annotate_func__-attribute","title":"3. New <code>__annotate_func__</code> Attribute","text":"<ul> <li>Classes now have <code>__annotate_func__</code> instead of/in addition to <code>__annotations__</code></li> <li>This appears in <code>dir()</code> output, breaking tests that check for specific attributes</li> <li>Test failure: <code>test_dir_includes_settings_and_methods</code></li> </ul>"},{"location":"python-3.14-issues/#4-from_env-completely-broken","title":"4. <code>from_env()</code> Completely Broken","text":"<ul> <li>Returns empty classes with no attributes</li> <li>Can't find any settings to extract from environment</li> <li>Test failures: All <code>test_from_env.py</code> tests</li> </ul>"},{"location":"python-3.14-issues/#5-command-line-argument-parsing-failures","title":"5. Command Line Argument Parsing Failures","text":"<ul> <li>Boolean Optional types fail with <code>SystemExit: 2</code></li> <li>Unable to handle <code>--debug true</code> style arguments</li> <li>Test failures: Multiple in <code>test_command_line.py</code></li> </ul>"},{"location":"python-3.14-issues/#6-pickle-error-message-changed-again","title":"6. Pickle Error Message Changed (Again)","text":"<ul> <li>Error message for pickling local classes changed from \"Can't get local object\" to something else</li> <li>This is minor but indicates ongoing changes in Python internals</li> <li>Test failure: <code>test_local_class_pickle_limitation</code></li> </ul>"},{"location":"python-3.14-issues/#code-areas-affected","title":"Code Areas Affected","text":""},{"location":"python-3.14-issues/#metacheapsettings__new__-lines-197-285","title":"<code>MetaCheapSettings.__new__()</code> (lines 197-285)","text":"<ul> <li>Lines 210-232: Annotation collection from parent classes</li> <li>Lines 230-233: Processing current class annotations via <code>dct.pop(\"__annotations__\", {})</code></li> <li>Lines 258-264: Handling annotations without defaults</li> </ul> <p>The core issue: <code>__annotations__</code> might not exist or might be empty even when annotations are present.</p>"},{"location":"python-3.14-issues/#_convert_value_to_type-lines-91-185","title":"<code>_convert_value_to_type()</code> (lines 91-185)","text":"<ul> <li>Still being called but receiving wrong type information</li> <li>Optional/Union detection failing at lines 117-135</li> </ul>"},{"location":"python-3.14-issues/#from_env-method-lines-545-583","title":"<code>from_env()</code> method (lines 545-583)","text":"<ul> <li>Line 567: <code>annotations = getattr(config_instance, \"__annotations__\", {})</code></li> <li>Returns empty dict in Python 3.14</li> </ul>"},{"location":"python-3.14-issues/#potential-solution-approaches","title":"Potential Solution Approaches","text":""},{"location":"python-3.14-issues/#1-check-for-__annotate_func__","title":"1. Check for <code>__annotate_func__</code>","text":"<pre><code># In MetaCheapSettings.__new__\nif hasattr(dct, '__annotate_func__'):\n    # Python 3.14+ path\n    annotate_func = dct['__annotate_func__']\n    annotations = annotate_func(1)  # Format parameter: 1 = VALUE format\nelse:\n    # Python 3.8-3.13 path\n    annotations = dct.pop(\"__annotations__\", {})\n</code></pre>"},{"location":"python-3.14-issues/#2-update-annotation-collection","title":"2. Update Annotation Collection","text":"<p>Need to handle both eager (3.13-) and lazy (3.14+) evaluation: - Try <code>__annotate_func__()</code> first if it exists - Fall back to <code>__annotations__</code> - May need to force evaluation of annotations during metaclass creation</p>"},{"location":"python-3.14-issues/#3-fix-dir-implementation","title":"3. Fix <code>dir()</code> Implementation","text":"<ul> <li>Filter out <code>__annotate_func__</code> from the attribute list</li> <li>Or document it as an expected attribute in 3.14+</li> </ul>"},{"location":"python-3.14-issues/#test-output-summary","title":"Test Output Summary","text":"<p>Failed: 33 tests Passed: 125 tests Categories of failure: - Optional/Union type conversion: 12 tests - Uninitialized settings: 9 tests - from_env(): 7 tests - Command line parsing: 4 tests - Pickle: 1 test</p>"},{"location":"python-3.14-issues/#why-this-is-hard-to-fix","title":"Why This Is Hard to Fix","text":"<ol> <li>Fundamental change: This isn't a bug fix, it's adapting to a new Python architecture</li> <li>Metaclass timing: We build the config at class creation time, but annotations are now lazy</li> <li>Backward compatibility: Need to support both old and new systems (3.8-3.13 vs 3.14+)</li> <li>Limited documentation: PEP 649 is implemented but real-world migration guides are scarce</li> </ol>"},{"location":"python-3.14-issues/#recommendation","title":"Recommendation","text":"<ol> <li>Short term: Keep Python 3.14 in the \"not supported\" list</li> <li>Medium term: Wait for the Python community to develop patterns for handling this</li> <li>Long term: Implement dual-path support when patterns emerge</li> </ol>"},{"location":"python-3.14-issues/#references","title":"References","text":"<ul> <li>PEP 649: The specification</li> <li>Python 3.14 Release Notes: Official changes</li> <li>Test failures: <code>.save/3-14-test-failures.txt</code></li> </ul>"},{"location":"python-3.14-issues/#for-future-implementation","title":"For Future Implementation","text":"<p>When ready to tackle this: 1. Set up a Python 3.14 development environment 2. Create a minimal test case for annotation handling 3. Implement <code>__annotate_func__</code> support in the metaclass 4. Test extensively with both 3.13 and 3.14 5. Consider if this warrants a major version bump (2.0.0)</p> <p>Note: This document created November 2025 based on test failures from GitHub Actions CI run.</p>"}]}