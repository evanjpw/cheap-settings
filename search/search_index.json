{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cheap Settings","text":"<p>A lightweight, low footprint settings system</p> <p> </p> <p><code>cheap-settings</code> is a Python package for providing a very simple, very low impact, configuration. The Python configuration &amp; settings landscape is virtually overflowing with clever, advanced, flexible solutions that cover many needs. However, what I needed was a bit different from any config/settings package that I was aware of.</p> <p>The main thing that distinguishes <code>cheap_settings</code> from any alternative solutions is simplicity: it is extremely simple (&amp; ergonomic) to use, &amp; it intentionally limits its scope &amp; feature set to be simple to understand.</p> <p>Additionally, it supports circumstances where it is difficult to bring your config file with you. All of your config is defined in the code or in the environment.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>from cheap_settings import CheapSettings\n\nclass MySettings(CheapSettings):\n    host: str = \"localhost\"\n    port: int = 8080\n    debug: bool = False\n\n# Access settings\nprint(f\"Server: {MySettings.host}:{MySettings.port}\")\n\n# Override with environment variables\n# HOST=production.com PORT=443 DEBUG=true python myapp.py\n</code></pre> <p>Environment variables automatically override defaults with proper type conversion.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install cheap-settings\n</code></pre>"},{"location":"#features","title":"Features","text":"<ul> <li>Simple: Just inherit from <code>CheapSettings</code> and define typed attributes</li> <li>Environment variables: Automatic override with type conversion</li> <li>Command line: Optional CLI argument parsing</li> <li>Type safe: Full type hints and IDE support</li> <li>Inheritance: Settings classes can inherit from each other</li> <li>Pickleable: Works with Ray and other frameworks requiring serialization</li> <li>Zero dependencies: No external requirements</li> <li>Performance: Optional static snapshots for speed-critical code</li> </ul>"},{"location":"#why-cheap-settings","title":"Why Cheap Settings?","text":"<p>You want to configure something. You don't want to spend time configuring the configuration system. You just want it to work with minimal ceremony.</p> <p>That's exactly what <code>cheap-settings</code> provides.</p>"},{"location":"api/","title":"API Reference","text":""},{"location":"api/#cheapsettings","title":"CheapSettings","text":""},{"location":"api/#cheap_settings.CheapSettings","title":"<code>cheap_settings.CheapSettings</code>","text":"<p>Base class for simple, environment-variable-driven configuration.</p> <p>Subclass this and define your settings as typed class attributes:</p> <pre><code>class MySettings(CheapSettings):\n    host: str = \"localhost\"\n    port: int = 8080\n    debug: bool = False\n</code></pre> Environment variables will override the defaults <p>HOST=example.com PORT=3000 DEBUG=true python myapp.py</p> <p>Supports all basic Python types plus Optional and Union types (or Path types). Complex types (list, dict) are parsed from JSON strings.</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>class CheapSettings(metaclass=MetaCheapSettings):\n    \"\"\"Base class for simple, environment-variable-driven configuration.\n\n    Subclass this and define your settings as typed class attributes:\n\n        class MySettings(CheapSettings):\n            host: str = \"localhost\"\n            port: int = 8080\n            debug: bool = False\n\n    Environment variables will override the defaults:\n        HOST=example.com PORT=3000 DEBUG=true python myapp.py\n\n    Supports all basic Python types plus Optional and Union types (or Path\n    types). Complex types (list, dict) are parsed from JSON strings.\n    \"\"\"\n\n    def __getattribute__(self, name):\n        \"\"\"Allow instances to access class-level settings.\"\"\"\n        # First try regular instance attribute access\n        try:\n            return object.__getattribute__(self, name)\n        except AttributeError:\n            # Fall back to class-level attribute access\n            # This allows instances to access settings defined at the class level\n            return getattr(type(self), name)\n\n    def __reduce__(self):\n        \"\"\"Enable pickling by returning class and state information.\"\"\"\n        # Try to return the class directly if it can be imported\n        try:\n            module = importlib.import_module(self.__class__.__module__)\n            if hasattr(module, self.__class__.__name__):\n                cls = getattr(module, self.__class__.__name__)\n                return cls, (), self.__getstate__()\n        except (ImportError, AttributeError):\n            pass\n\n        # Fallback to reconstruction\n        return (\n            _reconstruct_settings_instance,\n            (self.__class__.__module__, self.__class__.__name__),\n            self.__getstate__(),\n        )\n\n    def __getstate__(self):\n        \"\"\"Get the state for pickling - returns a dict of all settings.\"\"\"\n        # For CheapSettings, we don't actually have instance state\n        # All settings are class-level, so we just return an empty dict\n        return {}\n\n    def __setstate__(self, state):\n        \"\"\"Restore state when unpickling.\"\"\"\n        # Nothing to restore for CheapSettings instances\n        # All settings are accessed from the class level\n        pass\n\n    @classmethod\n    def to_static(cls) -&gt; object:\n        \"\"\"Create a static snapshot of current settings as a regular class.\n        The returned class is a regular Python class without any dynamic behavior.\n\n        Returns:\n             object: a new class with all settings resolved to their current values.\n\n        This is useful for:\n        - Performance-critical code where attribute access overhead matters\n        - Situations where you want to freeze settings at a point in time\n        - Working around edge cases with the dynamic metaclass behavior\n\n        Example:\n            &gt;&gt;&gt; class MySettings(CheapSettings):\n            ...     host: str = \"localhost\"\n            ...     port: int = 8080\n            &gt;&gt;&gt; StaticSettings = MySettings.to_static()\n            &gt;&gt;&gt; StaticSettings.host  # Just a regular class attribute\n            'localhost'\n        \"\"\"\n        # Collect all settings and their current resolved values\n        attrs = {}\n\n        # Get all settings from the class (including inherited ones)\n        for name in dir(cls):\n            # Skip private attributes and methods\n            if name.startswith(\"_\"):\n                continue\n\n            # Get the attribute value\n            try:\n                value = getattr(cls, name)\n            except AttributeError:\n                continue\n\n            # Skip methods and other callables\n            if callable(value):\n                continue\n\n            # Add the resolved value to our static class\n            attrs[name] = value\n\n        # Create a new regular class with the resolved values\n        static_class = type(f\"Static{cls.__name__}\", (), attrs)\n\n        # Copy the module for better repr and debugging\n        static_class.__module__ = cls.__module__\n\n        return static_class\n\n    @classmethod\n    def set_config_from_command_line(cls, arg_parser=None, args=None):\n        \"\"\"Creates command line arguments (as flags) that correspond to the settings, &amp; parses them, setting the\n        config values based on them. Settings overridden by command line arguments take precedence over any\n        default variables, &amp; over environment variables. Currently, settings of `dict` &amp; `list` types are ignored,\n        &amp; no command line arguments are added for them. It can optionally take an instance of argparse.ArgumentParser\n        that can be used to pre-configure your own command line arguments. The optional `args` parameter allows\n        passing specific arguments for testing (if None, uses sys.argv). Returns the parsed arguments (an\n        instance of argparse.Namespace). Can raise various exceptions.\"\"\"\n\n        # Create a second config instance specifically for command line arguments. This adds a new class attribute\n        # called `__cli_config_instance`, &amp; adds any command line arguments that correspond to the attributes of\n        # `__config_instance`. It also copies any type annotations for the copied attributes.\n        try:\n            config_instance = object.__getattribute__(cls, \"__config_instance\")\n        except AttributeError:\n            raise AttributeError(\"Config instance has not been set.\")\n\n        if config_instance is None:\n            raise AttributeError(\"Config instance has not been set.\")\n\n        cli_config_instance = MetaCheapSettings.ConfigInstance()\n        parsed_args = parse_command_line_arguments(\n            config_instance, cli_config_instance, arg_parser, args\n        )\n        # Use type.__setattr__ to set attribute on the class\n        type.__setattr__(cls, \"__cli_config_instance\", cli_config_instance)\n\n        return parsed_args\n</code></pre>"},{"location":"api/#cheap_settings.CheapSettings.__getattribute__","title":"<code>__getattribute__(name)</code>","text":"<p>Allow instances to access class-level settings.</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>def __getattribute__(self, name):\n    \"\"\"Allow instances to access class-level settings.\"\"\"\n    # First try regular instance attribute access\n    try:\n        return object.__getattribute__(self, name)\n    except AttributeError:\n        # Fall back to class-level attribute access\n        # This allows instances to access settings defined at the class level\n        return getattr(type(self), name)\n</code></pre>"},{"location":"api/#cheap_settings.CheapSettings.__getstate__","title":"<code>__getstate__()</code>","text":"<p>Get the state for pickling - returns a dict of all settings.</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>def __getstate__(self):\n    \"\"\"Get the state for pickling - returns a dict of all settings.\"\"\"\n    # For CheapSettings, we don't actually have instance state\n    # All settings are class-level, so we just return an empty dict\n    return {}\n</code></pre>"},{"location":"api/#cheap_settings.CheapSettings.__reduce__","title":"<code>__reduce__()</code>","text":"<p>Enable pickling by returning class and state information.</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>def __reduce__(self):\n    \"\"\"Enable pickling by returning class and state information.\"\"\"\n    # Try to return the class directly if it can be imported\n    try:\n        module = importlib.import_module(self.__class__.__module__)\n        if hasattr(module, self.__class__.__name__):\n            cls = getattr(module, self.__class__.__name__)\n            return cls, (), self.__getstate__()\n    except (ImportError, AttributeError):\n        pass\n\n    # Fallback to reconstruction\n    return (\n        _reconstruct_settings_instance,\n        (self.__class__.__module__, self.__class__.__name__),\n        self.__getstate__(),\n    )\n</code></pre>"},{"location":"api/#cheap_settings.CheapSettings.__setstate__","title":"<code>__setstate__(state)</code>","text":"<p>Restore state when unpickling.</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>def __setstate__(self, state):\n    \"\"\"Restore state when unpickling.\"\"\"\n    # Nothing to restore for CheapSettings instances\n    # All settings are accessed from the class level\n    pass\n</code></pre>"},{"location":"api/#cheap_settings.CheapSettings.set_config_from_command_line","title":"<code>set_config_from_command_line(arg_parser=None, args=None)</code>  <code>classmethod</code>","text":"<p>Creates command line arguments (as flags) that correspond to the settings, &amp; parses them, setting the config values based on them. Settings overridden by command line arguments take precedence over any default variables, &amp; over environment variables. Currently, settings of <code>dict</code> &amp; <code>list</code> types are ignored, &amp; no command line arguments are added for them. It can optionally take an instance of argparse.ArgumentParser that can be used to pre-configure your own command line arguments. The optional <code>args</code> parameter allows passing specific arguments for testing (if None, uses sys.argv). Returns the parsed arguments (an instance of argparse.Namespace). Can raise various exceptions.</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>@classmethod\ndef set_config_from_command_line(cls, arg_parser=None, args=None):\n    \"\"\"Creates command line arguments (as flags) that correspond to the settings, &amp; parses them, setting the\n    config values based on them. Settings overridden by command line arguments take precedence over any\n    default variables, &amp; over environment variables. Currently, settings of `dict` &amp; `list` types are ignored,\n    &amp; no command line arguments are added for them. It can optionally take an instance of argparse.ArgumentParser\n    that can be used to pre-configure your own command line arguments. The optional `args` parameter allows\n    passing specific arguments for testing (if None, uses sys.argv). Returns the parsed arguments (an\n    instance of argparse.Namespace). Can raise various exceptions.\"\"\"\n\n    # Create a second config instance specifically for command line arguments. This adds a new class attribute\n    # called `__cli_config_instance`, &amp; adds any command line arguments that correspond to the attributes of\n    # `__config_instance`. It also copies any type annotations for the copied attributes.\n    try:\n        config_instance = object.__getattribute__(cls, \"__config_instance\")\n    except AttributeError:\n        raise AttributeError(\"Config instance has not been set.\")\n\n    if config_instance is None:\n        raise AttributeError(\"Config instance has not been set.\")\n\n    cli_config_instance = MetaCheapSettings.ConfigInstance()\n    parsed_args = parse_command_line_arguments(\n        config_instance, cli_config_instance, arg_parser, args\n    )\n    # Use type.__setattr__ to set attribute on the class\n    type.__setattr__(cls, \"__cli_config_instance\", cli_config_instance)\n\n    return parsed_args\n</code></pre>"},{"location":"api/#cheap_settings.CheapSettings.to_static","title":"<code>to_static()</code>  <code>classmethod</code>","text":"<p>Create a static snapshot of current settings as a regular class. The returned class is a regular Python class without any dynamic behavior.</p> <p>Returns:</p> Name Type Description <code>object</code> <code>Type[Any]</code> <p>a new class with all settings resolved to their current values.</p> <p>This is useful for: - Performance-critical code where attribute access overhead matters - Situations where you want to freeze settings at a point in time - Working around edge cases with the dynamic metaclass behavior</p> Example <p>class MySettings(CheapSettings): ...     host: str = \"localhost\" ...     port: int = 8080 StaticSettings = MySettings.to_static() StaticSettings.host  # Just a regular class attribute 'localhost'</p> Source code in <code>src/cheap_settings/cheap_settings.py</code> <pre><code>@classmethod\ndef to_static(cls) -&gt; object:\n    \"\"\"Create a static snapshot of current settings as a regular class.\n    The returned class is a regular Python class without any dynamic behavior.\n\n    Returns:\n         object: a new class with all settings resolved to their current values.\n\n    This is useful for:\n    - Performance-critical code where attribute access overhead matters\n    - Situations where you want to freeze settings at a point in time\n    - Working around edge cases with the dynamic metaclass behavior\n\n    Example:\n        &gt;&gt;&gt; class MySettings(CheapSettings):\n        ...     host: str = \"localhost\"\n        ...     port: int = 8080\n        &gt;&gt;&gt; StaticSettings = MySettings.to_static()\n        &gt;&gt;&gt; StaticSettings.host  # Just a regular class attribute\n        'localhost'\n    \"\"\"\n    # Collect all settings and their current resolved values\n    attrs = {}\n\n    # Get all settings from the class (including inherited ones)\n    for name in dir(cls):\n        # Skip private attributes and methods\n        if name.startswith(\"_\"):\n            continue\n\n        # Get the attribute value\n        try:\n            value = getattr(cls, name)\n        except AttributeError:\n            continue\n\n        # Skip methods and other callables\n        if callable(value):\n            continue\n\n        # Add the resolved value to our static class\n        attrs[name] = value\n\n    # Create a new regular class with the resolved values\n    static_class = type(f\"Static{cls.__name__}\", (), attrs)\n\n    # Copy the module for better repr and debugging\n    static_class.__module__ = cls.__module__\n\n    return static_class\n</code></pre>"},{"location":"api/#type-support","title":"Type Support","text":"<p><code>cheap-settings</code> automatically converts environment variable strings to the appropriate Python types based on type annotations.</p>"},{"location":"api/#supported-types","title":"Supported Types","text":"Type Example Environment Variable Notes <code>str</code> <code>\"hello\"</code> <code>VALUE=\"hello\"</code> No conversion needed <code>int</code> <code>42</code> <code>VALUE=\"42\"</code> Converted with <code>int()</code> <code>float</code> <code>3.14</code> <code>VALUE=\"3.14\"</code> Converted with <code>float()</code> <code>bool</code> <code>True</code> <code>VALUE=\"true\"</code> Accepts: true/false, yes/no, on/off, 1/0 (case-insensitive) <code>pathlib.Path</code> <code>Path(\"/etc\")</code> <code>VALUE=\"/etc\"</code> Converted with <code>Path()</code> <code>list</code> <code>[1, 2, 3]</code> <code>VALUE='[1, 2, 3]'</code> Parsed as JSON <code>dict</code> <code>{\"key\": \"value\"}</code> <code>VALUE='{\"key\": \"value\"}'</code> Parsed as JSON <code>Optional[T]</code> <code>None</code> or <code>T</code> <code>VALUE=\"none\"</code> or valid <code>T</code> Special \"none\" string sets to None <code>Union[T, U]</code> <code>T</code> or <code>U</code> Valid for either type Tries each type in order"},{"location":"api/#environment-variable-naming","title":"Environment Variable Naming","text":"<p>Environment variables are the uppercase version of the attribute name:</p> <pre><code>class Settings(CheapSettings):\n    database_url: str = \"localhost\"     # DATABASE_URL\n    api_timeout: int = 30               # API_TIMEOUT\n    enable_cache: bool = False          # ENABLE_CACHE\n</code></pre>"},{"location":"api/#command-line-arguments","title":"Command Line Arguments","text":"<p>Command line arguments are the lowercase, hyphenated version of the attribute name:</p> <pre><code>class Settings(CheapSettings):\n    database_url: str = \"localhost\"     # --database-url\n    api_timeout: int = 30               # --api-timeout\n    enable_cache: bool = False          # --enable-cache / --no-enable-cache\n</code></pre>"},{"location":"api/#inheritance","title":"Inheritance","text":"<p>Settings classes support inheritance. Child classes inherit all settings from parent classes and can override them:</p> <pre><code>class BaseSettings(CheapSettings):\n    timeout: int = 30\n\nclass WebSettings(BaseSettings):\n    timeout: int = 60  # Override parent\n    port: int = 8080   # Add new setting\n</code></pre>"},{"location":"api/#error-handling","title":"Error Handling","text":"<ul> <li>Type conversion errors: If an environment variable can't be converted to the expected type, a <code>ValueError</code> is raised with details</li> <li>JSON parsing errors: For <code>list</code> and <code>dict</code> types, JSON parsing errors include helpful messages</li> <li>Missing attributes: Accessing undefined settings raises <code>AttributeError</code></li> </ul>"},{"location":"api/#performance","title":"Performance","text":"<p>For performance-critical code where attribute access overhead matters, use <code>to_static()</code> to create a snapshot with no dynamic behavior:</p> <pre><code>Settings = MyDynamicSettings.to_static()\n# Now Settings.value is just a regular class attribute\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>The best way to understand <code>cheap-settings</code> is through examples. All examples are runnable - you can copy and paste them into Python files.</p>"},{"location":"examples/#basic-usage","title":"Basic Usage","text":"<p>The simplest way to use cheap-settings:</p> <pre><code>from cheap_settings import CheapSettings\n\nclass AppSettings(CheapSettings):\n    \"\"\"Application configuration.\"\"\"\n    host: str = \"localhost\"\n    port: int = 8080\n    debug: bool = False\n    app_name: str = \"MyApp\"\n\n# Access settings directly as class attributes\nprint(f\"Host: {AppSettings.host}\")\nprint(f\"Port: {AppSettings.port}\")\nprint(f\"Server: http://{AppSettings.host}:{AppSettings.port}\")\n</code></pre>"},{"location":"examples/#environment-variables","title":"Environment Variables","text":"<p>Environment variables automatically override defaults with type conversion:</p> <pre><code>import os\nfrom cheap_settings import CheapSettings\n\nclass Settings(CheapSettings):\n    database_host: str = \"localhost\"\n    database_port: int = 5432\n    connection_timeout: float = 30.0\n    use_ssl: bool = False\n\n# Set environment variables\nos.environ[\"DATABASE_HOST\"] = \"prod.example.com\"\nos.environ[\"DATABASE_PORT\"] = \"3306\"  # Converted to int\nos.environ[\"USE_SSL\"] = \"true\"        # Converted to bool\n\nprint(f\"Database: {Settings.database_host}:{Settings.database_port}\")\nprint(f\"SSL: {Settings.use_ssl} ({type(Settings.use_ssl).__name__})\")\n</code></pre>"},{"location":"examples/#command-line-arguments","title":"Command Line Arguments","text":"<p>Automatically create CLI arguments from your settings:</p> <pre><code>from cheap_settings import CheapSettings\n\nclass ServerConfig(CheapSettings):\n    host: str = \"0.0.0.0\"\n    port: int = 8000\n    workers: int = 4\n    reload: bool = False\n\n# Parse command line arguments\nServerConfig.set_config_from_command_line()\n\nprint(f\"Server: {ServerConfig.host}:{ServerConfig.port}\")\nprint(f\"Workers: {ServerConfig.workers}\")\n</code></pre> <p>Run with: <code>python server.py --host localhost --port 3000 --workers 8 --reload</code></p>"},{"location":"examples/#inheritance","title":"Inheritance","text":"<p>Settings classes can inherit from each other:</p> <pre><code>from cheap_settings import CheapSettings\n\nclass BaseConfig(CheapSettings):\n    app_name: str = \"MyApplication\"\n    version: str = \"1.0.0\"\n    timeout: int = 30\n\nclass DatabaseConfig(BaseConfig):\n    db_host: str = \"localhost\"\n    db_port: int = 5432\n    db_name: str = \"myapp\"\n\nclass ProductionConfig(DatabaseConfig):\n    debug: bool = False\n    db_host: str = \"prod.db.example.com\"  # Override parent\n    ssl_required: bool = True\n\nprint(f\"App: {ProductionConfig.app_name} v{ProductionConfig.version}\")\nprint(f\"Database: {ProductionConfig.db_host}:{ProductionConfig.db_port}\")\n</code></pre>"},{"location":"examples/#type-conversion","title":"Type Conversion","text":"<p>All basic Python types are supported, with or without type annotations:</p> <pre><code>from pathlib import Path\nfrom typing import Optional\nfrom cheap_settings import CheapSettings\n\nclass TypedSettings(CheapSettings):\n    # Explicit type annotations\n    text: str = \"default\"\n    number: int = 42\n    ratio: float = 3.14\n    enabled: bool = False\n\n    # Type inference from defaults (no annotations needed!)\n    host = \"localhost\"  # Infers str\n    port = 8080  # Infers int\n    timeout = 30.5  # Infers float\n    debug = False  # Infers bool\n\n    # Path support\n    config_dir: Path = Path(\"/etc/myapp\")\n    # Or inferred:\n    log_dir = Path(\"/var/log\")  # Infers Path\n\n    # JSON types\n    tags: list = [\"python\", \"config\"]\n    metadata: dict = {\"version\": 1}\n\n    # Optional types (need explicit annotation)\n    api_key: Optional[str] = None\n\n# Environment variables are converted automatically:\n# TEXT=\"hello\" NUMBER=\"99\" ENABLED=\"true\" CONFIG_DIR=\"/custom/path\"\n# TAGS='[\"web\", \"api\"]' METADATA='{\"env\": \"prod\"}' API_KEY=\"secret\"\n</code></pre>"},{"location":"examples/#static-snapshots","title":"Static Snapshots","text":"<p>For performance-critical code, create static snapshots:</p> <pre><code>from cheap_settings import CheapSettings\n\nclass DynamicSettings(CheapSettings):\n    api_url: str = \"https://api.example.com\"\n    timeout: int = 30\n    retry_count: int = 3\n\n# Create a static snapshot (frozen values)\nStaticSettings = DynamicSettings.to_static()\n\n# Static class has no dynamic behavior - just fast attribute access\nprint(f\"API: {StaticSettings.api_url}\")\nprint(f\"Type: {type(StaticSettings)}\")  # Regular Python class\n</code></pre>"},{"location":"examples/#pickle-support","title":"Pickle Support","text":"<p>Works with Ray and other frameworks requiring serialization:</p> <pre><code>import pickle\nfrom cheap_settings import CheapSettings\n\nclass Config(CheapSettings):\n    host: str = \"localhost\"\n    port: int = 8080\n\n# Pickle and unpickle\npickled = pickle.dumps(Config)\nunpickled_class = pickle.loads(pickled)\n\nassert unpickled_class.host == Config.host\nprint(\"\u2713 Pickle support works!\")\n</code></pre>"},{"location":"examples/#more-examples","title":"More Examples","text":"<p>For complete runnable examples, see the examples directory in the repository.</p>"}]}